{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { Plugin } from 'vite';\r\nexport interface AutoLoadingOptions {\r\n    debug?: boolean;\r\n}\r\nexport function autoLoadingPlugin(options: AutoLoadingOptions = {}): Plugin {\r\n    const { debug = false } = options;\r\n    return {\r\n        name: 'vite-plugin-loading',\r\n        enforce: 'pre',\r\n        transform(code, id) {\r\n            try {\r\n                if (!id.endsWith('.vue')) return code;\r\n                if (debug) {\r\n                  console.debug(`[vite-plugin-auto-loading] Processing ${id}`);\r\n              }\r\n                // 只匹配 reactive 定义的 loading\r\n                const reactiveMatch = code.match(/loading\\s*=\\s*reactive\\s*\\(\\s*{([^}]*)}\\s*\\)/);\r\n                const refMatch = code.match(/loading\\s*=\\s*ref\\s*\\(\\s*{([^}]*)}\\s*\\)/);\r\n                const loadingMatch = reactiveMatch || refMatch;\r\n                if (!loadingMatch) return code;\r\n\r\n                // 提取 loading keys\r\n                const loadingKeys = loadingMatch[1]\r\n                    .split(',')\r\n                    .map((item) => item.trim())\r\n                    .filter(Boolean)\r\n                    .map((item) => item.split(':')[0].trim());\r\n                console.log(loadingKeys, 2222);\r\n                if (loadingKeys.length === 0) return code;\r\n\r\n                // 查找函数体结束位置\r\n                const findClosingBrace = (str: string, startIndex: number) => {\r\n                    let count = 1;\r\n                    let i = startIndex;\r\n                    let inString = false;\r\n                    let stringChar = '';\r\n\r\n                    while (i < str.length && count > 0) {\r\n                        const char = str[i];\r\n                        // 处理字符串\r\n                        if ((char === '\"' || char === \"'\") && str[i - 1] !== '\\\\') {\r\n                            if (!inString) {\r\n                                inString = true;\r\n                                stringChar = char;\r\n                            } else if (char === stringChar) {\r\n                                inString = false;\r\n                            }\r\n                        }\r\n                        // 计数括号\r\n                        if (!inString) {\r\n                            if (char === '{') count++;\r\n                            if (char === '}') count--;\r\n                        }\r\n                        i++;\r\n                    }\r\n                    return i;\r\n                };\r\n\r\n                // 包装函数体\r\n                const wrapFunctionBody = (body: string, key: string) => {\r\n                    const indentMatch = body.match(/^\\s+/);\r\n                    const indent = indentMatch ? indentMatch[0] : '  ';\r\n\r\n                    return `\r\n${indent}loading.${key} = true;\r\n${indent}try {\r\n${body}${indent}} finally {\r\n${indent}  loading.${key} = false;\r\n${indent}}`;\r\n                };\r\n\r\n                let transformedCode = code;\r\n\r\n                // 定义所有需要匹配的函数模式\r\n                const patterns = [\r\n                    // 箭头函数: const name = async () => {}\r\n                    {\r\n                        regex: (key: string) =>\r\n                            new RegExp(\r\n                                `const\\\\s+${key}\\\\s*=\\\\s*async\\\\s*\\\\([^)]*\\\\)\\\\s*=>\\\\s*{`,\r\n                                'g'\r\n                            ),\r\n                        processMatch: (match: RegExpExecArray, key: string) => ({\r\n                            start: match.index,\r\n                            bodyStart: match.index + match[0].length\r\n                        })\r\n                    },\r\n                    // 普通函数: async function name() {}\r\n                    {\r\n                        regex: (key: string) =>\r\n                            new RegExp(`async\\\\s+function\\\\s+${key}\\\\s*\\\\([^)]*\\\\)\\\\s*{`, 'g'),\r\n                        processMatch: (match: RegExpExecArray, key: string) => ({\r\n                            start: match.index,\r\n                            bodyStart: match.index + match[0].length\r\n                        })\r\n                    },\r\n                    // setup方法: name: async () => {}\r\n                    {\r\n                        regex: (key: string) =>\r\n                            new RegExp(`${key}:\\\\s*async\\\\s*\\\\([^)]*\\\\)\\\\s*=>\\\\s*{`, 'g'),\r\n                        processMatch: (match: RegExpExecArray, key: string) => ({\r\n                            start: match.index,\r\n                            bodyStart: match.index + match[0].length\r\n                        })\r\n                    }\r\n                ];\r\n\r\n                // 处理每个 loading key\r\n                loadingKeys.forEach((key) => {\r\n                    // 检查函数是否包含 await\r\n                    const hasAwait = (body: string) => /\\bawait\\b/.test(body);\r\n\r\n                    // 应用每个模式\r\n                    patterns.forEach((pattern) => {\r\n                        const regex = pattern.regex(key);\r\n                        let match;\r\n\r\n                        while ((match = regex.exec(transformedCode)) !== null) {\r\n                            const { start, bodyStart } = pattern.processMatch(match, key);\r\n                            const bodyEnd = findClosingBrace(transformedCode, bodyStart);\r\n\r\n                            if (bodyEnd > bodyStart) {\r\n                                const prefix = transformedCode.slice(start, bodyStart);\r\n                                const body = transformedCode.slice(bodyStart, bodyEnd - 1);\r\n\r\n                                // 只处理包含 await 的函数\r\n                                if (hasAwait(body)) {\r\n                                    const newBody = wrapFunctionBody(body, key);\r\n                                    transformedCode =\r\n                                        transformedCode.slice(0, start) +\r\n                                        prefix +\r\n                                        newBody +\r\n                                        '}' +\r\n                                        transformedCode.slice(bodyEnd);\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n\r\n                return transformedCode;\r\n            } catch (e) {\r\n                console.error(`[vite-plugin-loading] Error processing ${id}:`, e);\r\n                return code; // 发生错误时返回原始代码\r\n            }\r\n        }\r\n    };\r\n}\r\n"],"mappings":"AAIO,SAASA,EAAkBC,EAA8B,CAAC,EAAW,CACxE,GAAM,CAAE,MAAAC,EAAQ,EAAM,EAAID,EAC1B,MAAO,CACH,KAAM,sBACN,QAAS,MACT,UAAUE,EAAMC,EAAI,CAChB,GAAI,CACA,GAAI,CAACA,EAAG,SAAS,MAAM,EAAG,OAAOD,EAC7BD,GACF,QAAQ,MAAM,yCAAyCE,CAAE,EAAE,EAG7D,IAAMC,EAAgBF,EAAK,MAAM,8CAA8C,EACzEG,EAAWH,EAAK,MAAM,yCAAyC,EAC/DI,EAAeF,GAAiBC,EACtC,GAAI,CAACC,EAAc,OAAOJ,EAG1B,IAAMK,EAAcD,EAAa,CAAC,EAC7B,MAAM,GAAG,EACT,IAAKE,GAASA,EAAK,KAAK,CAAC,EACzB,OAAO,OAAO,EACd,IAAKA,GAASA,EAAK,MAAM,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC,EAE5C,GADA,QAAQ,IAAID,EAAa,IAAI,EACzBA,EAAY,SAAW,EAAG,OAAOL,EAGrC,IAAMO,EAAmB,CAACC,EAAaC,IAAuB,CAC1D,IAAIC,EAAQ,EACRC,EAAIF,EACJG,EAAW,GACXC,EAAa,GAEjB,KAAOF,EAAIH,EAAI,QAAUE,EAAQ,GAAG,CAChC,IAAMI,EAAON,EAAIG,CAAC,GAEbG,IAAS,KAAOA,IAAS,MAAQN,EAAIG,EAAI,CAAC,IAAM,OAC5CC,EAGME,IAASD,IAChBD,EAAW,KAHXA,EAAW,GACXC,EAAaC,IAMhBF,IACGE,IAAS,KAAKJ,IACdI,IAAS,KAAKJ,KAEtBC,GACJ,CACA,OAAOA,CACX,EAGMI,EAAmB,CAACC,EAAcC,IAAgB,CACpD,IAAMC,EAAcF,EAAK,MAAM,MAAM,EAC/BG,EAASD,EAAcA,EAAY,CAAC,EAAI,KAE9C,MAAO;AAAA,EACzBC,CAAM,WAAWF,CAAG;AAAA,EACpBE,CAAM;AAAA,EACNH,CAAI,GAAGG,CAAM;AAAA,EACbA,CAAM,aAAaF,CAAG;AAAA,EACtBE,CAAM,GACQ,EAEIC,EAAkBpB,EAGhBqB,EAAW,CAEb,CACI,MAAQJ,GACJ,IAAI,OACA,YAAYA,CAAG,2CACf,GACJ,EACJ,aAAc,CAACK,EAAwBL,KAAiB,CACpD,MAAOK,EAAM,MACb,UAAWA,EAAM,MAAQA,EAAM,CAAC,EAAE,MACtC,EACJ,EAEA,CACI,MAAQL,GACJ,IAAI,OAAO,wBAAwBA,CAAG,uBAAwB,GAAG,EACrE,aAAc,CAACK,EAAwBL,KAAiB,CACpD,MAAOK,EAAM,MACb,UAAWA,EAAM,MAAQA,EAAM,CAAC,EAAE,MACtC,EACJ,EAEA,CACI,MAAQL,GACJ,IAAI,OAAO,GAAGA,CAAG,uCAAwC,GAAG,EAChE,aAAc,CAACK,EAAwBL,KAAiB,CACpD,MAAOK,EAAM,MACb,UAAWA,EAAM,MAAQA,EAAM,CAAC,EAAE,MACtC,EACJ,CACJ,EAGA,OAAAjB,EAAY,QAASY,GAAQ,CAEzB,IAAMM,EAAYP,GAAiB,YAAY,KAAKA,CAAI,EAGxDK,EAAS,QAASG,GAAY,CAC1B,IAAMC,EAAQD,EAAQ,MAAMP,CAAG,EAC3BK,EAEJ,MAAQA,EAAQG,EAAM,KAAKL,CAAe,KAAO,MAAM,CACnD,GAAM,CAAE,MAAAM,EAAO,UAAAC,CAAU,EAAIH,EAAQ,aAAaF,EAAOL,CAAG,EACtDW,EAAUrB,EAAiBa,EAAiBO,CAAS,EAE3D,GAAIC,EAAUD,EAAW,CACrB,IAAME,EAAST,EAAgB,MAAMM,EAAOC,CAAS,EAC/CX,EAAOI,EAAgB,MAAMO,EAAWC,EAAU,CAAC,EAGzD,GAAIL,EAASP,CAAI,EAAG,CAChB,IAAMc,EAAUf,EAAiBC,EAAMC,CAAG,EAC1CG,EACIA,EAAgB,MAAM,EAAGM,CAAK,EAC9BG,EACAC,EACA,IACAV,EAAgB,MAAMQ,CAAO,CACrC,CACJ,CACJ,CACJ,CAAC,CACL,CAAC,EAEMR,CACX,OAASW,EAAG,CACR,eAAQ,MAAM,0CAA0C9B,CAAE,IAAK8B,CAAC,EACzD/B,CACX,CACJ,CACJ,CACJ","names":["autoLoadingPlugin","options","debug","code","id","reactiveMatch","refMatch","loadingMatch","loadingKeys","item","findClosingBrace","str","startIndex","count","i","inString","stringChar","char","wrapFunctionBody","body","key","indentMatch","indent","transformedCode","patterns","match","hasAwait","pattern","regex","start","bodyStart","bodyEnd","prefix","newBody","e"]}